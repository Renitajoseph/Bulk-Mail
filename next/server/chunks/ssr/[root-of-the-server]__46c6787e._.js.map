{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 223, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.5-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 244, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/ai-rate-limiter.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview Implements an AI-powered rate limiter for email sending.\n *\n * - `rateLimitEmail` -  A function that determines whether an email should be sent based on real-time factors.\n * - `RateLimitEmailInput` - The input type for the rateLimitEmail function.\n * - `RateLimitEmailOutput` - The return type for the rateLimitEmail function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst RateLimitEmailInputSchema = z.object({\n  recipientEmail: z.string().email().describe('The email address of the recipient.'),\n  emailContent: z.string().describe('The content of the email being sent.'),\n  senderReputationScore: z\n    .number()\n    .min(0)\n    .max(1)\n    .describe(\n      'A score representing the sender reputation, from 0 (poor) to 1 (excellent).'\n    ),\n  recipientEngagementScore: z\n    .number()\n    .min(0)\n    .max(1)\n    .describe(\n      'A score representing the recipient engagement, from 0 (no engagement) to 1 (high engagement).'\n    ),\n});\nexport type RateLimitEmailInput = z.infer<typeof RateLimitEmailInputSchema>;\n\nconst RateLimitEmailOutputSchema = z.object({\n  shouldSendEmail: z\n    .boolean()\n    .describe(\n      'A boolean value indicating whether the email should be sent (true) or blocked (false).'\n    ),\n  reason: z\n    .string()\n    .describe(\n      'A string providing a reason for the decision, for logging or debugging purposes.'\n    ),\n});\nexport type RateLimitEmailOutput = z.infer<typeof RateLimitEmailOutputSchema>;\n\nexport async function rateLimitEmail(input: RateLimitEmailInput): Promise<RateLimitEmailOutput> {\n  return rateLimitEmailFlow(input);\n}\n\nconst rateLimitPrompt = ai.definePrompt({\n  name: 'rateLimitPrompt',\n  input: {schema: RateLimitEmailInputSchema},\n  output: {schema: RateLimitEmailOutputSchema},\n  prompt: `You are an AI-powered rate limiter that dynamically adjusts email sending frequency to avoid spam flags.\n\n  Based on the following information, determine whether an email should be sent to the recipient:\n\n  - Recipient Email: {{{recipientEmail}}}\n  - Email Content: {{{emailContent}}}\n  - Sender Reputation Score: {{{senderReputationScore}}} (0 = Poor, 1 = Excellent)\n  - Recipient Engagement Score: {{{recipientEngagementScore}}} (0 = No Engagement, 1 = High Engagement)\n\n  Consider factors such as sender reputation, recipient engagement, and email content to make your decision.\n\n  Respond with JSON in the following format:\n  {\n    \"shouldSendEmail\": true or false,\n    \"reason\": \"A brief explanation for the decision\"\n  }`,\n});\n\nconst rateLimitEmailFlow = ai.defineFlow(\n  {\n    name: 'rateLimitEmailFlow',\n    inputSchema: RateLimitEmailInputSchema,\n    outputSchema: RateLimitEmailOutputSchema,\n  },\n  async input => {\n    const {output} = await rateLimitPrompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AACA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,4BAA4B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACzC,gBAAgB,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,KAAK,GAAG,QAAQ,CAAC;IAC5C,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAClC,uBAAuB,uIAAA,CAAA,IAAC,CACrB,MAAM,GACN,GAAG,CAAC,GACJ,GAAG,CAAC,GACJ,QAAQ,CACP;IAEJ,0BAA0B,uIAAA,CAAA,IAAC,CACxB,MAAM,GACN,GAAG,CAAC,GACJ,GAAG,CAAC,GACJ,QAAQ,CACP;AAEN;AAGA,MAAM,6BAA6B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC1C,iBAAiB,uIAAA,CAAA,IAAC,CACf,OAAO,GACP,QAAQ,CACP;IAEJ,QAAQ,uIAAA,CAAA,IAAC,CACN,MAAM,GACN,QAAQ,CACP;AAEN;AAGO,eAAe,eAAe,KAA0B;IAC7D,OAAO,mBAAmB;AAC5B;AAEA,MAAM,kBAAkB,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IACtC,MAAM;IACN,OAAO;QAAC,QAAQ;IAAyB;IACzC,QAAQ;QAAC,QAAQ;IAA0B;IAC3C,QAAQ,CAAC;;;;;;;;;;;;;;;GAeR,CAAC;AACJ;AAEA,MAAM,qBAAqB,mHAAA,CAAA,KAAE,CAAC,UAAU,CACtC;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,gBAAgB;IACvC,OAAO;AACT;;;IAnCoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 320, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/actions.ts"],"sourcesContent":["'use server';\n\nimport { z } from 'zod';\nimport { rateLimitEmail, type RateLimitEmailOutput } from '@/ai/flows/ai-rate-limiter';\nimport type { EmailBatch, EmailResult } from '@/lib/types';\n\nconst FormSchema = z.object({\n  subject: z.string().min(1, 'Subject is required.'),\n  body: z.string().min(1, 'Email body is required.'),\n  recipients: z.string().min(1, 'Recipients are required.'),\n});\n\ntype State = {\n  message?: string | null;\n  errors?: {\n    subject?: string[];\n    body?: string[];\n    recipients?: string[];\n  };\n  batch?: EmailBatch | null;\n};\n\nexport async function sendBulkEmail(prevState: State, formData: FormData): Promise<State> {\n  const validatedFields = FormSchema.safeParse({\n    subject: formData.get('subject'),\n    body: formData.get('body'),\n    recipients: formData.get('recipients'),\n  });\n\n  if (!validatedFields.success) {\n    return {\n      errors: validatedFields.error.flatten().fieldErrors,\n      message: 'Missing Fields. Failed to Send Email.',\n    };\n  }\n\n  const recipients = validatedFields.data.recipients\n    .split(/[\\n,;]+/)\n    .map((email) => email.trim())\n    .filter((email) => email.length > 0 && z.string().email().safeParse(email).success)\n    .filter((value, index, self) => self.indexOf(value) === index); // Unique emails\n\n  if (recipients.length === 0) {\n    return { message: 'Please provide at least one valid recipient email.' };\n  }\n\n  const emailContent = `Subject: ${validatedFields.data.subject}\\n\\n${validatedFields.data.body}`;\n\n  const results: EmailResult[] = await Promise.all(\n    recipients.map(async (recipient) => {\n      const senderReputationScore = Math.random();\n      const recipientEngagementScore = Math.random();\n\n      try {\n        const rateLimitResult: RateLimitEmailOutput = await rateLimitEmail({\n          recipientEmail: recipient,\n          emailContent,\n          senderReputationScore,\n          recipientEngagementScore,\n        });\n\n        if (rateLimitResult.shouldSendEmail) {\n          // Here you would integrate with a real email service like Nodemailer\n          return { recipient, status: 'Sent', reason: rateLimitResult.reason };\n        } else {\n          return { recipient, status: 'Blocked', reason: rateLimitResult.reason };\n        }\n      } catch (error) {\n        console.error('Error with AI rate limiter for recipient:', recipient, error);\n        return {\n          recipient,\n          status: 'Failed',\n          reason: 'An error occurred while processing with the AI rate limiter.',\n        };\n      }\n    })\n  );\n\n  const batch: EmailBatch = {\n    id: new Date().toISOString(),\n    subject: validatedFields.data.subject,\n    body: validatedFields.data.body,\n    recipients: recipients,\n    results,\n    sentAt: new Date().toISOString(),\n  };\n\n  return { message: 'Email batch processing complete.', batch };\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;;;;;;AAGA,MAAM,aAAa,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC1B,SAAS,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;IAC3B,MAAM,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;IACxB,YAAY,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;AAChC;AAYO,eAAe,cAAc,SAAgB,EAAE,QAAkB;IACtE,MAAM,kBAAkB,WAAW,SAAS,CAAC;QAC3C,SAAS,SAAS,GAAG,CAAC;QACtB,MAAM,SAAS,GAAG,CAAC;QACnB,YAAY,SAAS,GAAG,CAAC;IAC3B;IAEA,IAAI,CAAC,gBAAgB,OAAO,EAAE;QAC5B,OAAO;YACL,QAAQ,gBAAgB,KAAK,CAAC,OAAO,GAAG,WAAW;YACnD,SAAS;QACX;IACF;IAEA,MAAM,aAAa,gBAAgB,IAAI,CAAC,UAAU,CAC/C,KAAK,CAAC,WACN,GAAG,CAAC,CAAC,QAAU,MAAM,IAAI,IACzB,MAAM,CAAC,CAAC,QAAU,MAAM,MAAM,GAAG,KAAK,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,KAAK,GAAG,SAAS,CAAC,OAAO,OAAO,EACjF,MAAM,CAAC,CAAC,OAAO,OAAO,OAAS,KAAK,OAAO,CAAC,WAAW,QAAQ,gBAAgB;IAElF,IAAI,WAAW,MAAM,KAAK,GAAG;QAC3B,OAAO;YAAE,SAAS;QAAqD;IACzE;IAEA,MAAM,eAAe,CAAC,SAAS,EAAE,gBAAgB,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,gBAAgB,IAAI,CAAC,IAAI,EAAE;IAE/F,MAAM,UAAyB,MAAM,QAAQ,GAAG,CAC9C,WAAW,GAAG,CAAC,OAAO;QACpB,MAAM,wBAAwB,KAAK,MAAM;QACzC,MAAM,2BAA2B,KAAK,MAAM;QAE5C,IAAI;YACF,MAAM,kBAAwC,MAAM,CAAA,GAAA,2IAAA,CAAA,iBAAc,AAAD,EAAE;gBACjE,gBAAgB;gBAChB;gBACA;gBACA;YACF;YAEA,IAAI,gBAAgB,eAAe,EAAE;gBACnC,qEAAqE;gBACrE,OAAO;oBAAE;oBAAW,QAAQ;oBAAQ,QAAQ,gBAAgB,MAAM;gBAAC;YACrE,OAAO;gBACL,OAAO;oBAAE;oBAAW,QAAQ;oBAAW,QAAQ,gBAAgB,MAAM;gBAAC;YACxE;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,6CAA6C,WAAW;YACtE,OAAO;gBACL;gBACA,QAAQ;gBACR,QAAQ;YACV;QACF;IACF;IAGF,MAAM,QAAoB;QACxB,IAAI,IAAI,OAAO,WAAW;QAC1B,SAAS,gBAAgB,IAAI,CAAC,OAAO;QACrC,MAAM,gBAAgB,IAAI,CAAC,IAAI;QAC/B,YAAY;QACZ;QACA,QAAQ,IAAI,OAAO,WAAW;IAChC;IAEA,OAAO;QAAE,SAAS;QAAoC;IAAM;AAC9D;;;IAlEsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 413, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {sendBulkEmail as '6061ed9eab1bec6aa26858106807f59ae6f93c9a2e'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}},
    {"offset": {"line": 465, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/app/email-form.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const EmailForm = registerClientReference(\n    function() { throw new Error(\"Attempted to call EmailForm() from the server but EmailForm is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/app/email-form.tsx <module evaluation>\",\n    \"EmailForm\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,YAAY,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EAC3C;IAAa,MAAM,IAAI,MAAM;AAAkO,GAC/P,mEACA","debugId":null}},
    {"offset": {"line": 479, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/components/app/email-form.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport const EmailForm = registerClientReference(\n    function() { throw new Error(\"Attempted to call EmailForm() from the server but EmailForm is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/app/email-form.tsx\",\n    \"EmailForm\",\n);\n"],"names":[],"mappings":";;;AAAA;;AACO,MAAM,YAAY,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EAC3C;IAAa,MAAM,IAAI,MAAM;AAAkO,GAC/P,+CACA","debugId":null}},
    {"offset": {"line": 493, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 503, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/page.tsx"],"sourcesContent":["import { EmailForm } from '@/components/app/email-form';\n\nexport default function Home() {\n  return (\n    <div className=\"container mx-auto p-4 md:p-8 flex-1\">\n      <EmailForm />\n    </div>\n  );\n}\n"],"names":[],"mappings":";;;;AAAA;;;AAEe,SAAS;IACtB,qBACE,8OAAC;QAAI,WAAU;kBACb,cAAA,8OAAC,0IAAA,CAAA,YAAS;;;;;;;;;;AAGhB","debugId":null}}]
}